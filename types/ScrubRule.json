{
  "$schema": "http://json-schema.org/draft-04/schema#",
  "description": "ScrubRule",
  "allOf": [
    {
      "$ref": "file:///types/Rule.json#"
    },
    {
      "$ref": "file:///types/RuleWithInterfaceFilter.json#"
    },
    {
      "$ref": "file:///types/RuleWithAfFilter.json#"
    },
    {
      "$ref": "file:///types/RuleWithLoggingOption.json#"
    },
    {
      "$ref": "file:///types/RuleWithTrafficSelector.json#"
    },
    {
      "$ref": "file:///types/RuleWithTagFilter.json#"
    },
    {
      "type": "object",
      "required": [
        "direction",
        "no",
        "no_df",
        "min_ttl",
        "max_mss",
        "set_tos",
        "random_identifier",
        "fragment_reassemble",
        "fragment_crop",
        "fragment_drop_ovl",
        "reassemble_tcp"
      ],
      "properties": {
        "direction": {
          "type": "string",
          "enum": [
            "in",
            "out",
            "both"
          ],
          "description": "This rule applies to incoming or outgoing packets. If neither in nor out are specified, the rule will match packets in both directions.",
          "default": "both"
        },
        "no": {
          "type": "boolean",
          "description": "The no option prefixed to a scrub rule causes matching packets to remain unscrubbed, much in the same way as drop quick works in the packet filter (see below).  This mechanism should be used when it is necessary to exclude specific packets from broader scrub rules.",
          "default": false
        },
        "no_df": {
          "type": "boolean",
          "default": false,
          "description": "Clears the dont-fragment bit from a matching IP packet.  Some operating systems are known to generate fragmented packets with the dont-fragment bit set.  This is particularly true with NFS. Scrub will drop such fragmented dont-fragment packets unless no-df is specified.\nUnfortunately some operating systems also generate their dont-fragment packets with a zero IP identification field.  Clearing the dont-fragment bit on packets with a zero IP ID may cause deleterious results if an upstream router later fragments the packet.  Using the random-id modifier (see below) is recommended in combination with the no-df modifier to ensure unique IP identifiers."
        },
        "min_ttl": {
          "type": "integer",
          "default": -1,
          "description": "Enforces a minimum TTL for matching IP packets."
        },
        "max_mss": {
          "type": "integer",
          "default": -1,
          "description": "Enforces a maximum MSS for matching TCP packets."
        },
        "set_tos": {
          "type": "string",
          "description": "Enforces a TOS for matching IP packets.  TOS may be given as one of lowdelay, throughput, reliability, or as either hex or decimal."
        },
        "random_identifier": {
          "type": "boolean",
          "description": "Replaces the IP identification field with random values to compensate for predictable values generated by many hosts.  This option only applies to packets that are not fragmented after the optional fragment reassembly.",
          "default": false
        },
        "fragment_reassemble": {
          "type": "boolean",
          "default": false,
          "description": "Using scrub rules, fragments can be reassembled by normalization. In this case, fragments are buffered until they form a complete packet, and only the completed packet is passed on to the filter. The advantage is that filter rules have to deal only with complete packets, and can ignore fragments.  The drawback of caching fragments is the additional memory cost.  But the full reassembly method is the only method that currently works with NAT.  This is the default behavior of a scrub rule if no fragmentation modifier is supplied."
        },
        "fragment_crop": {
          "type": "boolean",
          "default": false,
          "description": "The default fragment reassembly method is expensive, hence the option to crop is provided. In this case, pf(4) will track the fragments and cache a small range descriptor.  Duplicate fragments are dropped and overlaps are cropped.  Thus data will only occuronce on the wire with ambiguities resolving to the first occurrence.  Unlike the fragment reassemble modifier, fragments are not buffered, they are passed as soon as they are received.  The fragment crop reassembly mechanism does not yet work with NAT."
        },
        "fragment_drop_ovl": {
          "type": "boolean",
          "default": false,
          "description": "This option is similar to the fragment crop modifier except that all overlapping or duplicate fragments will be dropped, and all further corresponding fragments will be dropped as well."
        },
        "reassemble_tcp": {
          "type": "boolean",
          "default": false,
          "description": "Statefully normalizes TCP connections.  scrub reassemble tcp rules may not have the direction (in/out) specified."
        }
      }
    }
  ]
}
